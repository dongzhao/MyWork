<#@ template debug="true" hostspecific="true" language="C#" #>

<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)MyWork.model\bin\Debug\MyWork.Model.dll" #>
<#@ assembly name="$(SolutionDir)MyWork.model\bin\Debug\MyWork.Core.dll" #>

<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="MyWork.Model" #>
<#@ import namespace="MyWork.Core" #>

<#@ output extension=".cs" #>

<#@ include file="ModelHelper.tt" #>

<#
    var modelPath = getSolutionUrl() + @"\MyWork.Model\bin\Debug\MyWork.Model.dll";
    var asse = Assembly.LoadFrom(modelPath);
    var typeList = asse.GetTypes();
    var myNameSpace = "MyWork";
    var contextName = "MyWorkDbContext";

    // beginning of looping class
    foreach(var type in typeList){
        if(!typeof(IEntity<int>).IsAssignableFrom(type) || type.IsAbstract || type.IsInterface || !type.IsClass){
            continue;
        }
        var className = type.Name;
        string fieldIdType = getTypeOfIdField();

        // add eager loading reference model
        var included = new List<string>();
        foreach(PropertyInfo pi in type.GetProperties()){
            var fieldName = pi.Name;
            var fieldType = pi.PropertyType.FullName;
            if(fieldType.IndexOf(myNameSpace+".Model.")>=0){
                // only look into Model namespace
                var attr = pi.GetCustomAttribute(typeof(ModelAttribute));
                if(attr != null){
                    ModelAttribute myAttr = attr as ModelAttribute;
                    if(myAttr.EagerLoading){
                        included.Add(fieldName);
                    }
                }
            }
        }
#>
/**
The class generated by codegen 
*/
using <#=myNameSpace#>.Model;
using System;
using System.Data;
using System.Data.Entity;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace <#=myNameSpace#>.Repository
{
    public class <#=className#>Repository : I<#=className#>Repository
    {
        protected readonly <#=contextName#> ctx;
        public <#=className#>Repository(<#=contextName#> context){
            this.ctx = context;
        }

        public void Delete(<#=fieldIdType#> id){
            var <#=className.ToLower()#> = ctx.<#=className#>Set.SingleOrDefault(e => e.Id == id);
            if(ctx.Entry(<#=className.ToLower()#>).State == EntityState.Detached){
                ctx.<#=className#>Set.Attach(<#=className.ToLower()#>);
            };
            ctx.<#=className#>Set.Remove(<#=className.ToLower()#>);
            ctx.SaveChanges();
        }

        public IEnumerable<<#=className#>> GetAll()
        {
            return ctx.<#=className#>Set
<#
foreach(var name in included){
#>
            .Include(e => e.<#=name#>)
<#
}
#>
            .ToList();
        }

        public <#=className#> GetById(<#=fieldIdType#> id)
        {
            return ctx.<#=className#>Set
<#
foreach(var name in included){
#>
            .Include(e => e.<#=name#>)
<#
}
#>
            .SingleOrDefault(e => e.Id == id);
        }

        public <#=fieldIdType#> Create(<#=className#> <#=className.ToLower()#>)
        {
            ctx.<#=className#>Set.Add(<#=className.ToLower()#>);
            ctx.SaveChanges();
            return <#=className.ToLower()#>.Id;
        }

        public void Update(<#=className#> <#=className.ToLower()#>)
        {
            ctx.<#=className#>Set.Attach(<#=className.ToLower()#>);
            ctx.Entry(<#=className.ToLower()#>).State = EntityState.Modified;
            ctx.SaveChanges();
        }
 <#
        // to lool each field property for generating methods
        foreach(PropertyInfo pi in type.GetProperties()){
            var fieldName = pi.Name;
            var fieldType = pi.PropertyType.FullName;
            if(fieldType.IndexOf(myNameSpace+".Model.")>=0){
                // to skip the field from Model namespace
                continue;
            }
            // to check attribute
            var propTypeName = "";
            var attr = pi.GetCustomAttribute(typeof(ModelAttribute));
            if(attr != null){
                ModelAttribute myAttr = attr as ModelAttribute;
                if(myAttr.Searchable){
                    if(pi.PropertyType.GenericTypeArguments.Length > 0){
                        propTypeName = pi.PropertyType.GenericTypeArguments[0].FullName;
                    }else{
                        propTypeName = fieldType;
                    }
                    if(propTypeName == typeof(DateTime).FullName){
 #>
        public IEnumerable<<#=className#>> SearchBy<#=fieldName#>(<#=propTypeName#> fromDate, <#=propTypeName#> toDate)
        {
            return ctx.<#=className#>Set
<#
foreach(var name in included){
#>
            .Include(e => e.<#=name#>)
<#
}
#>
            .Where(e => e.<#=fieldName#> >= fromDate && e.<#=fieldName#> <= toDate).ToList();
        }
 <#                       
                    }else{
 #>
        public IEnumerable<<#=className#>> SearchBy<#=fieldName#>(<#=propTypeName#> <#=fieldName.ToLower()#>)
        {
            return ctx.<#=className#>Set
<#
foreach(var name in included){
#>
            .Include(e => e.<#=name#>)
<#
}
#>
            .Where(e => e.<#=fieldName#> == <#=fieldName.ToLower()#>).ToList();            
        }                
 <#                       
                    }
                }
            }
        }

 #>       
    }
}

<#
        SaveOutput(@"..\..\" + myNameSpace +@".Repository\generated\" + className + "Repository.cs");
    }
    // end of looping class
#>