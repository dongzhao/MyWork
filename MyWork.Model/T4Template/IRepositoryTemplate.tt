<#@ template debug="true" hostspecific="true" language="C#" #>

<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)MyWork.Model\bin\Debug\MyWork.Model.dll" #>
<#@ assembly name="$(SolutionDir)MyWork.model\bin\Debug\MyWork.Core.dll" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="System.Data.Entity" #>

<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="MyWork.Model" #>
<#@ import namespace="MyWork.Core" #>
<#@ import namespace="Newtonsoft.Json" #>
<#@ output extension=".cs" #>
<#@ include file="ModelHelper.tt" #>
<#
    var modelPath = getSolutionUrl() + @"\MyWork.Model\bin\Debug\MyWork.Model.dll";
    var asse = Assembly.LoadFrom(modelPath);
    var typeList = asse.GetTypes();
    var myNameSpace = "MyWork";
    var contextName = "MyWorkDbContext";
    // beginning of looping class
    foreach(var type in typeList)
    {
        if(!typeof(IEntity<int>).IsAssignableFrom(type) || type.IsAbstract || type.IsInterface || !type.IsClass)
        {
            continue;
        }
        var className = type.Name;
        string fieldIdType = getTypeOfIdField();

        // add eager loading reference model
        var included = new List<string>();
        foreach(PropertyInfo pi in type.GetProperties())
        {
            var fieldName = pi.Name;
            var fieldType = pi.PropertyType.FullName;
            if(fieldType.IndexOf(myNameSpace+".Model.")>=0)
            {
                // only look into Model namespace
                var attr = pi.GetCustomAttribute(typeof(ModelAttribute));
                if(attr != null){
                    ModelAttribute myAttr = attr as ModelAttribute;
                    if(myAttr.EagerLoading){
                        included.Add(fieldName);
                    }
                }
            }
        }
#>
/**
* The class generated by codegen 
*/
using <#=myNameSpace#>.Model;
using System;
using System.Data;
using System.Data.Entity;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using SYstem.Threading.Tasks;

namespace <#=myNameSpace#>.Repository
{
    public interface I<#=className#>Repository : IRepository<<#=className#>, <#=fieldIdType#>>
    {
<#
        // to lool each field property for generating methods
        foreach(PropertyInfo pi in type.GetProperties())
        {
            var fieldName = pi.Name;
            var fieldType = pi.PropertyType.FullName;
            if(fieldType.IndexOf(myNameSpace+".Model.")>=0)
            {
                // to skip the field from Model namespace
                continue;
            }
            // to check attribute
            var propTypeName = "";
            var attr = pi.GetCustomAttribute(typeof(ModelAttribute));
            if(attr != null){
                ModelAttribute myAttr = attr as ModelAttribute;
                if(myAttr.Searchable){
                    if(pi.PropertyType.GenericTypeArguments.Length > 0){
                        propTypeName = pi.PropertyType.GenericTypeArguments[0].FullName;
                    }else{
                        propTypeName = fieldType;
                    }
                    if(propTypeName == typeof(DateTime).FullName){
 #>
        IEnumerable<<#=className#>> SearchBy<#=fieldName#>(<#=propTypeName#> fromDate, <#=propTypeName#> toDate);   
 <#                       
                    }else{
 #>
        IEnumerable<<#=className#>> SearchBy<#=fieldName#>(<#=propTypeName#> <#=fieldName.ToLower()#>);                  
 <#                       
                    }
                }
            }
        }
 #>       
    }
}
<#
        SaveOutput(@"..\..\" + myNameSpace + @".Repository\generated\interfaces\I" + className + "Repository.cs");
    }
    // end of looping class
#>